KMD
00000000:             ; ;
00000000:             ; ; AdamOS
00000000:             ; ;
00000000:             ; 
00000000:             ; ; Exception Vectors ------------------------------------------------------------
00000000: EA000006    ; b       main                                    ; reset
00000004: EA00001A    ; b       undefinedInstruction    ; undefined instruction
00000008: EA000019    ; b       supervisorCall                  ; svc
0000000C: EA000018    ; b       prefetchAbort                   ; tried to execute code from non-existing memory region
                      ; s
00000010: EA000017    ; b       dataAbort                               ; data error (e.g. accessed out of bounds area)
00000014: E1A00000    ; nop
00000018: EA000015    ; b       irqRoutine                              ; interrupt request
0000001C: EA000014    ; b       fiqRoutine                              ; fast interrupt request
00000020:             ; 
00000020:             ; ; main -
00000020:             ; ;
00000020:             ; ;-
00000020:             ; main
00000020: E28FD0AC    ;         adrl sp, os_stack
00000024:             ; 
00000024: EB000093    ;         bl initializeLinkedList
00000028:             ; 
00000028: E28F001C    ;         adrl r0, main_add
0000002C: EB000097    ;         bl addNewProcess
00000030: E28F0028    ;         adrl r0, main_sub
00000034: EB000095    ;         bl addNewProcess
00000038:             ; 
00000038:             ;         ; switch to user mode
00000038: E10F0000    ;         mrs r0, cpsr
0000003C: E3C0001F    ;         bic r0, r0, #&1f
00000040: E3800010    ;         orr r0, r0, #&10
00000044: E121F000    ;         msr cpsr_c, r0
00000048:             ; 
00000048: EAFFFFFF    ;         b main_add
0000004C:             ; 
0000004C:             ; ; main_add ---------------------------------------------------------------------
0000004C:             ; ; testing the context switcher
0000004C:             ; ;-------------------------------------------------------------------------------
0000004C:             ; main_add
0000004C: E28FD0E0    ;         adrl sp, add_stack
00000050: E3A00000    ;         mov r0, #0
00000054:             ;         addloop
00000054: E2800001    ;                 add r0, r0, #1
00000058: EB000051    ;                 bl contextSwitch
0000005C: EAFFFFFC    ;                 b addloop
00000060:             ; 
00000060:             ; ; main_sub ---------------------------------------------------------------------
00000060:             ; ; testing the context switcher
00000060:             ; ;-------------------------------------------------------------------------------
00000060:             ; main_sub
00000060: E28FDF4B    ;         adrl sp, sub_stack
00000064: E3A000FF    ;         mov r0, #255
00000068:             ;         subloop
00000068: E2400001    ;                 sub r0, r0, #1
0000006C: EB00004C    ;                 bl contextSwitch
00000070: EAFFFFFC    ;                 b subloop
00000074:             ; 
00000074:             ; ; undefinedInstruction -
00000074:             ; ;
00000074:             ; ;- 
00000074:             ; undefinedInstruction
00000074:             ; 
00000074:             ; ; superVisorCall -
00000074:             ; ;
00000074:             ; ;-
00000074:             ; supervisorCall
00000074:             ; 
00000074:             ; ; prefetchAbort -
00000074:             ; ;
00000074:             ; ;-
00000074:             ; prefetchAbort
00000074:             ; 
00000074:             ; ;- dataAbort
00000074:             ; ;
00000074:             ; ;-
00000074:             ; dataAbort
00000074:             ; 
00000074:             ; ;- irqRoutine -
00000074:             ; ;
00000074:             ; ;-
00000074:             ; irqRoutine
00000074:             ; 
00000074:             ; ;- fiqRoutine
00000074:             ; ;
00000074:             ; ;-
00000074:             ; fiqRoutine
00000074:             ; 
00000074:             ;         defs 96
000000D4:             ; os_stack
000000D4:             ; 
000000D4:             ;         defs 96
00000134:             ; add_stack
00000134:             ;         defs 96
00000194:             ; sub_stack
00000194:             ; 
00000194:             ; ll_space
00000194:             ;         defs 16
000001A4:             ; 
000001A4:             ; include context_switcher.s
000001A4:             ; ; context_switcher -------------------------------------------------------------
000001A4:             ; ;
000001A4:             ; ;-------------------------------------------------------------------------------
000001A4:             ; 
000001A4:             ; TEMP_IRQ_LR EQU &9D4
000001A4:             ; TEMP_R0 EQU &9D8
000001A4:             ; TEMP_R1 EQU &9DC
000001A4:             ; TEMP_IRQ_CPSR EQU &9E0
000001A4:             ; TEMP_SYSTEM_CPSR EQU &9E4
000001A4:             ; 
000001A4:             ; CURRENT_PROCESS_ID EQU &9E8
000001A4:             ; TOP_OF_QUEUE EQU &9EC
000001A4:             ; BOTTOM_OF_QUEUE EQU &AF0
000001A4:             ; 
000001A4:             ; PCB_PTR EQU &AF4
000001A4:             ; PROCESS_ID_COUNTER EQU &AF8
000001A4:             ; 
000001A4:             ; ; contextSwitch ----------------------------------------------------------------
000001A4:             ; ; Saves the state of the currently running process, including it's registers
000001A4:             ; ; r0-12, SP, LR & PC. Then loads up the state of the next process to be run,
000001A4:             ; ; and continues from where the process just switched into left off.
000001A4:             ; ;-------------------------------------------------------------------------------
000001A4:             ; contextSwitch
000001A4: E28FDF85    ;         adrl sp, temp_stack
000001A8:             ; 
000001A8:             ;         ;TODO redo this using the PCB instead of a stack.
000001A8:             ; 
000001A8:             ;         ; store r0 temporarily
000001A8: E92D0002    ;         push {r1}
000001AC: E92D0001    ;         push {r0}
000001B0: E59F0208    ;         ldr r0, =TEMP_R0
000001B4: E8BD0002    ;         pop {r1}
000001B8: E5001000    ;         str r1, [r0]
000001BC:             ; 
000001BC:             ;         ; store r1 temporarily
000001BC: E59F0200    ;         ldr r0, =TEMP_R1
000001C0: E8BD0002    ;         pop {r1}
000001C4: E5001000    ;         str r1, [r0]
000001C8:             ; 
000001C8:             ;         ; store the SPSR of the IRQ (this is the CPSR of User Mode / System Mode)
000001C8: E14F0000    ;         mrs r0, spsr
000001CC: E59F11F4    ;         ldr r1, =TEMP_SYSTEM_CPSR
000001D0: E5010000    ;         str r0, [r1]
000001D4:             ;         
000001D4:             ;         ; store the LR of the IRQ (this is the PC of User Mode / System Mode)
000001D4: E59F01F0    ;         ldr r0, =TEMP_IRQ_LR
000001D8: E501E000    ;         str lr, [r1]
000001DC:             ;         
000001DC:             ;         ; store the IRQ CPSR
000001DC: E10F0000    ;         mrs r0, cpsr
000001E0: E3A01E9E    ;         ldr r1, =TEMP_IRQ_CPSR
000001E4: E5010000    ;         str r0, [r1]
000001E8:             ; 
000001E8: E380001F    ;         orr r0, r0, #0x1F ; system mode, disable irq; fiq; thumb
000001EC: E121F000    ;         msr cpsr_c, r0 ; actually change to system mode
000001F0:             ; 
000001F0:             ;         ; Now should be in System Mode
000001F0:             ; 
000001F0:             ;         ; push the System CPSR
000001F0: E59F01D0    ;         ldr r0, =TEMP_SYSTEM_CPSR
000001F4: E5101000    ;         ldr r1, [r0]
000001F8: E92D0002    ;         push {r1}
000001FC:             ; 
000001FC: E59F01BC    ;         ldr r0, =TEMP_R0 ; restore r0.
00000200: E5100000    ;         ldr r0, [r0]
00000204: E59F11B8    ;         ldr r1, =TEMP_R1 ; restore r1
00000208: E5111000    ;         ldr r1, [r1] 
0000020C:             ; 
0000020C:             ;         ; push the all registers of process we are switching out of
0000020C: E92D5FFF    ;         push {r0-r12, lr}
00000210:             ; 
00000210:             ;         ; push the PC of the process we are switching out of
00000210: E59F01B4    ;         ldr r0, =TEMP_IRQ_LR ; this is the PC of the System / User Mode process
00000214: E5101000    ;         ldr r1, [r0]
00000218: E92D0002    ;         push {r1}
0000021C: EB000007    ;         bl storeSP ; Store the current process's SP.
00000220:             ; 
00000220:             ;         ; Now get the next process to be run
00000220: EB000014    ;         bl getNextPID
00000224: EB000009    ;         bl getPID_SP_Addr
00000228: E1A0D000    ;         mov sp, r0
0000022C: E8BD0001    ;         pop {r0} ; pop off the CPSR of the process (i.e. get the status bits)
00000230: E121F000    ;         msr cpsr_c, r0 ; switch to User Mode
00000234: E8BD5FFF    ;         pop {r0-r12, lr} 
00000238: E8BD8000    ;         pop {pc} ; state of process should now be as we left it.
0000023C:             ; 
0000023C:             ;         ; Need to re-enable IRQs & FIQs here.
0000023C:             ; 
0000023C:             ;         ; Return to process
0000023C: E1A0F00E    ;         mov pc, lr ; probably the incorrect way to do this
00000240:             ; 
00000240:             ; ; storeSP ----------------------------------------------------------------------
00000240:             ; ; stores the SP to the current_PID's area in linked-list index
00000240:             ; ;-------------------------------------------------------------------------------
00000240:             ; storeSP
00000240: E59F0188    ;         ldr r0, =TOP_OF_QUEUE
00000244: E5100000    ;         ldr r0, [r0]
00000248: E580D004    ;         str sp, [r0, #4]
0000024C: E1A0F00E    ;         mov pc, lr
00000250:             ; 
00000250:             ; ; getPID_SP_Addr ---------------------------------------------------------------
00000250:             ; ; returns (in r0) the address of where the SP-value is stored
00000250:             ; ; TODO redo this to use the PCB instead of the stack.
00000250:             ; ;-------------------------------------------------------------------------------
00000250:             ; getPID_SP_Addr
00000250:             ;         ; r0 contains the PID to search for
00000250: E3A01EAF    ;         ldr r1, =BOTTOM_OF_QUEUE ; load in the PID of the bottom process
00000254: E5111000    ;         ldr r1, [r1]
00000258: E5111000    ;         ldr r1, [r1]
0000025C: E1300001    ;         teq r0, r1 ; is this the PID we are looking for?
00000260: 0A000002    ;         beq pid_found
00000264:             ;         loop
00000264:             ;         ; is a fixed-memory linked list, #0 is PID, #4 is SP, #8 is next PID, etc.
00000264: E5911008    ;                 ldr r1, [r1, #8] 
00000268: E1300001    ;                 teq r0, r1
0000026C: 1AFFFFFC    ;                 bne loop
00000270:             ;         ; need to put some error-handling in here (e.g. if r0 contains PID that
00000270:             ;         ; does not exist).
00000270:             ;         pid_found
00000270: E5110000    ;                 ldr r0, [r1]
00000274: E1A0F00E    ;                 mov pc, lr
00000278:             ; 
00000278:             ; ; getNextPID -------------------------------------------------------------------
00000278:             ; ; gets the top PID of the queue, and moves it to the bottom. also, stores the
00000278:             ; ; PID to [CURRENT_PROCESS_ID]
00000278:             ; ;-------------------------------------------------------------------------------
00000278:             ; getNextPID
00000278:             ;         ;TODO
00000278:             ; 
00000278:             ; ; initalizeLinkedList ----------------------------------------------------------
00000278:             ; ; Sets the top and the bottom of the linked list queue to be at the address
00000278:             ; ; defined by the hardcoded value in os.s. I.e. sets the size of the list to 
00000278:             ; ; be 0.
00000278:             ; ;
00000278:             ; ; input:-  void
00000278:             ; ; output:- void
00000278:             ; ; creference:- void initializeLinkedList()
00000278:             ; ;-------------------------------------------------------------------------------
00000278:             ; initializeLinkedList
00000278: E59F0150    ;         ldr r0, =TOP_OF_QUEUE
0000027C: E24F10F0    ;         adrl r1, ll_space
00000280: E5001000    ;         str r1, [r0]
00000284: E3A00EAF    ;         ldr r0, =BOTTOM_OF_QUEUE
00000288: E5001000    ;         str r1, [r0]
0000028C:             ; 
0000028C: E1A0F00E    ;         mov pc, lr
00000290:             ; 
00000290:             ; ; addNewProcess ----------------------------------------------------------------
00000290:             ; ; Stores the first instruction of the new process to a new area in linked list.
00000290:             ; ;
00000290:             ; ; registers used:
00000290:             ; ;
00000290:             ; ; input:-
00000290:             ; ; r0: the PC of the new process
00000290:             ; ;
00000290:             ; ; general:-
00000290:             ; ; r1: the PID of the process
00000290:             ; ; r2: the address of BOTTOM_OF_QUEUE
00000290:             ; ; r3: the value stored at the pointer retrieved from BOTTOM_OF_QUEUE
00000290:             ; ;
00000290:             ; ; Cref: void addNewProcess(uint32 PID, uint32 PC)
00000290:             ; ;-------------------------------------------------------------------------------
00000290:             ; addNewProcess
00000290:             ; 
00000290:             ;         ; get the PID, update, and store it back.
00000290: E59F113C    ;         ldr r1, =PROCESS_ID_COUNTER
00000294: E5112000    ;         ldr r2, [r1]
00000298: E2822001    ;         add r2, r2, #1
0000029C: E5012000    ;         str r2, [r1]
000002A0: E1A01002    ;         mov r1, r2
000002A4:             ; 
000002A4:             ;         ; get the address of the bottom of the queue
000002A4: E3A02EAF    ;         ldr r2, =BOTTOM_OF_QUEUE
000002A8: E5123000    ;         ldr r3, [r2]
000002AC:             ; 
000002AC:             ;         ; update the new bottom of the queue
000002AC: E2433008    ;         sub r3, r3, #8
000002B0: E5023000    ;         str r3, [r2]
000002B4:             ; 
000002B4:             ;         ; store the PC at relative #0
000002B4: E4030004    ;         str r0, [r3], #-4
000002B8:             ;         ; store the PID at relative #-4
000002B8: E5031000    ;         str r1, [r3]
000002BC:             ; 
000002BC: E1A0F00E    ;         mov pc, lr
000002C0:             ; 
000002C0:             ; ; updatePCB_PTR ----------------------------------------------------------------
000002C0:             ; ; Places the address of the PCB into PCB_PTR.
000002C0:             ; ;-------------------------------------------------------------------------------
000002C0:             ; updatePCB_PTR
000002C0: E59F0110    ;         ldr r0, =PCB_PTR
000002C4: E28F1004    ;         adrl r1, PCB
000002C8: E5001000    ;         str r1, [r0]
000002CC: E1A0F00E    ;         mov pc, lr
000002D0:             ; 
000002D0:             ; ; PCB --------------------------------------------------------------------------
000002D0:             ; ; Process Control Block
000002D0:             ; ;
000002D0:             ; ; Each process requires 72 bytes of storages (18 32-bit values)
000002D0:             ; ;
000002D0:             ; ; Outline of values in each process block:
000002D0:             ; ; #0     stores the PID
000002D0:             ; ; #4-#52 stores r0-r12
000002D0:             ; ; #56    stores the SP (r13)
000002D0:             ; ; #60    stores the LR (r14)
000002D0:             ; ; #64    stores the PC (r15)
000002D0:             ; ; #68    stores the CPSR
000002D0:             ; ;-------------------------------------------------------------------------------
000002D0:             ; PCB
000002D0:             ;         pcb1
000002D0:             ;         defs 72
00000318:             ;         pcb2
00000318:             ;         defs 72
00000360:             ; 
00000360:             ; 
00000360:             ; 
00000360:             ;         defs 96
000003C0:             ; temp_stack      
000003C0:             ; 
000003C0:             ; 
000003C0: 000009D8    ; Remaining literals
000003C4: 000009DC    ; 
000003C8: 000009E4    ; 
000003CC: 000009D4    ; 
000003D0: 000009EC    ; 
000003D4: 00000AF8    ; 
000003D8: 00000AF4    ; 

Symbol Table: Labels
: main                              00000020  Local -- ARM
: main_add                          0000004C  Local -- ARM
: addloop                           00000054  Local -- ARM
: main_sub                          00000060  Local -- ARM
: subloop                           00000068  Local -- ARM
: undefinedInstruction              00000074  Local -- ARM
: supervisorCall                    00000074  Local -- ARM
: prefetchAbort                     00000074  Local -- ARM
: dataAbort                         00000074  Local -- ARM
: irqRoutine                        00000074  Local -- ARM
: fiqRoutine                        00000074  Local -- ARM
: os_stack                          000000D4  Local -- ARM
: add_stack                         00000134  Local -- ARM
: sub_stack                         00000194  Local -- ARM
: ll_space                          00000194  Local -- ARM
: TEMP_IRQ_LR                       000009D4  Value
: TEMP_R0                           000009D8  Value
: TEMP_R1                           000009DC  Value
: TEMP_IRQ_CPSR                     000009E0  Value
: TEMP_SYSTEM_CPSR                  000009E4  Value
: CURRENT_PROCESS_ID                000009E8  Value
: TOP_OF_QUEUE                      000009EC  Value
: BOTTOM_OF_QUEUE                   00000AF0  Value
: PCB_PTR                           00000AF4  Value
: PROCESS_ID_COUNTER                00000AF8  Value
: contextSwitch                     000001A4  Local -- ARM
: storeSP                           00000240  Local -- ARM
: getPID_SP_Addr                    00000250  Local -- ARM
: loop                              00000264  Local -- ARM
: pid_found                         00000270  Local -- ARM
: getNextPID                        00000278  Local -- ARM
: initializeLinkedList              00000278  Local -- ARM
: addNewProcess                     00000290  Local -- ARM
: updatePCB_PTR                     000002C0  Local -- ARM
: PCB                               000002D0  Local -- ARM
: pcb1                              000002D0  Local -- ARM
: pcb2                              00000318  Local -- ARM
: temp_stack                        000003C0  Local -- ARM
