KMD
00000000:             ; ;
00000000:             ; ; AdamOS
00000000:             ; ;
00000000:             ; 
00000000:             ; ;TODO: Find way to use timer to call interrupts in software
00000000:             ; ;TODO: Add a round-robin scheduler
00000000:             ; ;TODO: Add dynamic memory
00000000:             ; ;TODO: Add dynamically added processes
00000000:             ; 
00000000:             ; 
00000000:             ; ; Exception Vectors ------------------------------------------------------------
00000000: EA000006    ; b       main                                    ; reset
00000004: EA000035    ; b       undefinedInstruction    ; undefined instruction
00000008: EA000034    ; b       supervisorCall                  ; svc
0000000C: EA000033    ; b       prefetchAbort                   ; tried executing code from non-existing memory
00000010: EA000032    ; b       dataAbort                               ; data error (e.g. accessed out of bounds area)
00000014: E1A00000    ; nop
00000018: EA000030    ; b       irqRoutine                              ; interrupt request
0000001C: EA00002F    ; b       fiqRoutine                              ; fast interrupt request
00000020:             ; 
00000020:             ; ; main -------------------------------------------------------------------------
00000020:             ; ;
00000020:             ; ;-------------------------------------------------------------------------------
00000020:             ; main
00000020: E28FDF46    ;         adrl sp, os_stack
00000024:             ; 
00000024: EB0000BD    ;         bl initialise_PCB
00000028:             ; 
00000028: E28F001C    ;         adrl r0, main_add
0000002C: EB000010    ;         bl addNewProcess
00000030: E28F0028    ;         adrl r0, main_sub
00000034: EB00000E    ;         bl addNewProcess
00000038:             ; 
00000038: E10F0000    ;         mrs r0, cpsr ; switch to user mode
0000003C: E3C0001F    ;         bic r0, r0, #&1f
00000040: E3800010    ;         orr r0, r0, #&10
00000044: E121F000    ;         msr cpsr_c, r0
00000048:             ; 
00000048: EAFFFFFF    ;         b main_add
0000004C:             ; 
0000004C:             ; ; main_add ---------------------------------------------------------------------
0000004C:             ; ; testing the context switcher
0000004C:             ; ;-------------------------------------------------------------------------------
0000004C:             ; main_add
0000004C: E28FDF53    ;         adrl sp, add_stack
00000050: E3A00000    ;         mov r0, #0
00000054:             ;         addloop
00000054: E2800001    ;                 add r0, r0, #1
00000058: EB000068    ;                 bl contextSwitch
0000005C: EAFFFFFC    ;                 b addloop
00000060:             ; 
00000060:             ; ; main_sub ---------------------------------------------------------------------
00000060:             ; ; testing the context switcher
00000060:             ; ;-------------------------------------------------------------------------------
00000060:             ; main_sub
00000060: E28FDF66    ;         adrl sp, sub_stack
00000064: E3A000FF    ;         mov r0, #255
00000068:             ;         subloop
00000068: E2400001    ;                 sub r0, r0, #1
0000006C: EB000063    ;                 bl contextSwitch
00000070: EAFFFFFC    ;                 b subloop
00000074:             ; 
00000074:             ; ; addNewProcess ----------------------------------------------------------------
00000074:             ; ; registers used:
00000074:             ; ;
00000074:             ; ; input:-
00000074:             ; ; r0: the address of the program to run
00000074:             ; ;
00000074:             ; ; general:-
00000074:             ; ;
00000074:             ; ; Cref: void addNewProcess(uint32 PC)
00000074:             ; ;-------------------------------------------------------------------------------
00000074:             ; addNewProcess
00000074: E59F1380    ;         ldr r1, =FREE_PCB ;get a free PCB
00000078: E5111000    ;         ldr r1, [r1] ;get a free PCB
0000007C:             ; 
0000007C: E581003C    ;         str r0, [r1, #60] ;update the pcb with the new processes PC location
00000080:             ; 
00000080: E1A00001    ;         mov r0, r1 ; r0 is now the ptr to the grabbed pcb
00000084:             ;         ;we want to move the PCB we have acquired into the READY queue
00000084: E92D4000    ;         push {lr}
00000088: EB000001    ;         bl moveToReadyQueue
0000008C: E8BD4000    ;         pop {lr}
00000090:             ; 
00000090: E1A0F00E    ;         mov pc, lr
00000094:             ; 
00000094:             ; ; moveToReadyQueue -------------------------------------------------------------
00000094:             ; ; movees r0 (the processes PCB address) out of the FREE_PCB queue and into the
00000094:             ; ; ready queue, waiting for execution.
00000094:             ; ;
00000094:             ; ; input
00000094:             ; ;       r0: the processes PCB address
00000094:             ; ;-------------------------------------------------------------------------------
00000094:             ; moveToReadyQueue
00000094:             ;         ;we are always grabbing from the top of the FREE queue (eg. FREE_PTR)
00000094:             ; 
00000094:             ;         ;want to look at ready queue FIRST to see if there are any processes currently in it.
00000094: E3A01E9F    ;         ldr r1, =READY_PCB
00000098: E5112000    ;         ldr r2, [r1] 
0000009C: E3520000    ;         cmp r2, #0
000000A0: 1A000007    ;         bne movToRdyTail ; the READY_PCB is not empty
000000A4:             ; 
000000A4: E5010000    ;         str r0, [r1] ;move the grabbed pcb to READY_PCB
000000A8:             ; 
000000A8:             ;         ; now we want to update FREE_PTR
000000A8: E2800044    ;         add r0, r0, #68 
000000AC: E5102000    ;         ldr r2, [r0] ; get the pointer address of the grabbed pcb (eg. the next free pcb)
000000B0: E59F1344    ;         ldr r1, =FREE_PCB
000000B4: E5012000    ;         str r2, [r1] ;update the FREE_PTR
000000B8:             ; 
000000B8:             ;         ; now we want to update the pointer of the grabbed pcb to null
000000B8: E3A01000    ;         mov r1, #0 ;null pointer
000000BC: E5001000    ;         str r1, [r0] ;put null pointer in the ptr_address of the grabbed pcb
000000C0:             ; 
000000C0: E1A0F00E    ;         mov pc, lr ; grabbed pcb is now at top of READY_PCB
000000C4:             ; 
000000C4:             ;         movToRdyTail
000000C4:             ;                 ;the READY_PCB is not empty, we want to add this pcb ptr to the end then
000000C4: E59F1334    ;                 ldr r1, =READY_PCB_TAIL ;points to the last pcb's ptr
000000C8: E5111000    ;                 ldr r1, [r1] ;we now have the address of the last pcb's ptr
000000CC: E5012000    ;                 str r2, [r1] ;the grabbed pcb is now the last pcb
000000D0:             ; 
000000D0:             ;                 ;therefore, make the grabbed pcb's ptr null
000000D0: E2800044    ;                 add r0, r0, #68 ;get the pointer address of the grabbed pcb
000000D4: E3A01000    ;                 mov r1, #0
000000D8: E5001000    ;                 str r1, [r0] ; make the pointer address null
000000DC:             ; 
000000DC: E1A0F00E    ;         mov pc, lr ;grabbed ocb is now at tail of READY_PCB
000000E0:             ; 
000000E0:             ; 
000000E0:             ; 
000000E0:             ; 
000000E0:             ; 
000000E0:             ; 
000000E0:             ; 
000000E0:             ; ; undefinedInstruction -
000000E0:             ; ;
000000E0:             ; ;- 
000000E0:             ; undefinedInstruction
000000E0:             ; 
000000E0:             ; ; superVisorCall -
000000E0:             ; ;
000000E0:             ; ;-
000000E0:             ; supervisorCall
000000E0:             ; 
000000E0:             ; ; prefetchAbort -
000000E0:             ; ;
000000E0:             ; ;-
000000E0:             ; prefetchAbort
000000E0:             ; 
000000E0:             ; ;- dataAbort
000000E0:             ; ;
000000E0:             ; ;-
000000E0:             ; dataAbort
000000E0:             ; 
000000E0:             ; ;- irqRoutine -
000000E0:             ; ;
000000E0:             ; ;-
000000E0:             ; irqRoutine
000000E0:             ; 
000000E0:             ; ;- fiqRoutine
000000E0:             ; ;
000000E0:             ; ;-
000000E0:             ; fiqRoutine
000000E0:             ; 
000000E0:             ;         defs 96
00000140:             ; os_stack
00000140:             ; 
00000140:             ;         defs 96
000001A0:             ; add_stack
000001A0:             ;         defs 96
00000200:             ; sub_stack
00000200:             ; 
00000200:             ; include context_switcher.s
00000200:             ; ; context_switcher -------------------------------------------------------------
00000200:             ; ;
00000200:             ; ;
00000200:             ; ;-------------------------------------------------------------------------------
00000200:             ; 
00000200:             ; TEMP_IRQ_LR EQU &9D4
00000200:             ; TEMP_R0 EQU &9D8
00000200:             ; TEMP_R1 EQU &9DC
00000200:             ; TEMP_IRQ_CPSR EQU &9E0
00000200:             ; TEMP_SYSTEM_CPSR EQU &9E4
00000200:             ; 
00000200:             ; ; contextSwitch ----------------------------------------------------------------
00000200:             ; ; Saves the state of the currently running process, including it's registers
00000200:             ; ; r0-12, SP, LR & PC. Then loads up the state of the next process to be run,
00000200:             ; ; and continues from where the process just switched into left off.
00000200:             ; ;-------------------------------------------------------------------------------
00000200:             ; contextSwitch
00000200: E28FDF46    ;         adrl sp, temp_stack
00000204:             ; 
00000204: E92D0002    ;         push {r1} ; store r0 temporarily
00000208: E92D0001    ;         push {r0}
0000020C: E59F01F0    ;         ldr r0, =TEMP_R0
00000210: E8BD0002    ;         pop {r1}
00000214: E5001000    ;         str r1, [r0]
00000218:             ; 
00000218: E59F01E8    ;         ldr r0, =TEMP_R1 ; store r1 temporarily
0000021C: E8BD0002    ;         pop {r1}
00000220: E5001000    ;         str r1, [r0]
00000224:             ; 
00000224:             ;         ; store the SPSR of the IRQ (this is the CPSR of User Mode / System Mode)
00000224: E14F0000    ;         mrs r0, spsr
00000228: E59F11DC    ;         ldr r1, =TEMP_SYSTEM_CPSR
0000022C: E5010000    ;         str r0, [r1]
00000230:             ;         
00000230:             ;         ; store the LR of the IRQ (this is the PC of User Mode / System Mode)
00000230: E59F01D8    ;         ldr r0, =TEMP_IRQ_LR
00000234: E501E000    ;         str lr, [r1]
00000238:             ;         
00000238: E10F0000    ;         mrs r0, cpsr ; store the IRQ CPSR
0000023C: E3A01E9E    ;         ldr r1, =TEMP_IRQ_CPSR
00000240: E5010000    ;         str r0, [r1]
00000244:             ; 
00000244: E380001F    ;         orr r0, r0, #0x1F ; system mode, disable irq; fiq; thumb
00000248: E121F000    ;         msr cpsr_c, r0 ; actually change to system mode
0000024C:             ; 
0000024C: EB000002    ;         bl storeToPCB ;store to PCB
00000250:             ; 
00000250:             ;         ; Now get the next process to be run
00000250: E1A0D000    ;         mov sp, r0
00000254:             ;         
00000254: E121F000    ;         msr cpsr_c, r0 ; switch to User Mode
00000258:             ; 
00000258:             ;         ; Need to re-enable IRQs & FIQs here.
00000258:             ; 
00000258:             ;         ; Return to process
00000258: E1A0F00E    ;         mov pc, lr ; probably the incorrect way to do this
0000025C:             ; 
0000025C:             ; storeToPCB
0000025C: E4801004    ;         str r1, [r0], #4 ; store the PID
00000260:             ; 
00000260: E59F119C    ;         ldr r1, =TEMP_R0 ;get r0
00000264: E5111000    ;         ldr r1, [r1] ;get r0
00000268: E4801004    ;         str r1, [r0], #4 ;store r1
0000026C:             ; 
0000026C: E59F1194    ;         ldr r1, =TEMP_R1 ;get r1
00000270: E5111000    ;         ldr r1, [r1] ; get r1
00000274: E4801004    ;         str r1, [r0], #4 ;store r1
00000278:             ; 
00000278: E4802004    ;         str r2, [r0], #4
0000027C: E4803004    ;         str r3, [r0], #4
00000280: E4804004    ;         str r4, [r0], #4
00000284: E4805004    ;         str r5, [r0], #4
00000288: E4806004    ;         str r6, [r0], #4
0000028C: E4807004    ;         str r7, [r0], #4
00000290: E4808004    ;         str r8, [r0], #4
00000294: E4809004    ;         str r9, [r0], #4
00000298: E480A004    ;         str r10, [r0], #4
0000029C: E480B004    ;         str r11, [r0], #4
000002A0: E480C004    ;         str r12, [r0], #4
000002A4: E480D004    ;         str sp, [r0], #4
000002A8: E480E004    ;         str lr, [r0], #4 ;******THIS MIGHT BE A PROBLEM****** (not user's lr?)
000002AC: E480F004    ;         str pc, [r0], #4
000002B0:             ; 
000002B0: E59F1154    ;         ldr r1, =TEMP_SYSTEM_CPSR ;get the user mode CPSR
000002B4: E5111000    ;         ldr r1, [r1] ;get the user mode CPSR
000002B8: E5001000    ;         str r1, [r0] ; store the user mode CPSR
000002BC:             ; 
000002BC: E1A0F00E    ;         mov pc, lr
000002C0:             ; 
000002C0:             ; 
000002C0:             ;         defs 96
00000320:             ; temp_stack      
00000320:             ; 
00000320:             ; 
00000320:             ; include pcb.s
00000320:             ; FREE_PCB        EQU             &9E8
00000320:             ; ACTIVE_PCB      EQU             &9EC
00000320:             ; READY_PCB       EQU             &9F0
00000320:             ; READY_PCB_TAIL  EQU     &9F4
00000320:             ; 
00000320:             ; ; PCB --------------------------------------------------------------------------
00000320:             ; ; Process Control Block
00000320:             ; ;
00000320:             ; ; Each process requires 72 bytes of storages (18 32-bit values)
00000320:             ; ;
00000320:             ; ; Outline of values in each process block:
00000320:             ; ; #0-#48 stores r0-r12
00000320:             ; ; #52    stores the SP (r13)
00000320:             ; ; #56    stores the LR (r14)
00000320:             ; ; #60    stores the PC (r15)
00000320:             ; ; #64    stores the CPSR
00000320:             ; ; #68    stores the pointer to the next pcb
00000320:             ; ;-------------------------------------------------------------------------------
00000320:             ; 
00000320:             ; initialise_PCB  
00000320:             ;         ; update FREE_PCB with the address of pcb_start
00000320: E28F003C    ;         adrl r0, pcb_start
00000324: E59F10D0    ;         ldr r1, =FREE_PCB
00000328: E5010000    ;         str r0, [r1]
0000032C:             ; 
0000032C: E2800044    ;         add r0, r0, #68 ;move to the ptr section of the first pcb
00000330: E2801004    ;         add r1, r0, #4 ;create the ptr address
00000334: E5001000    ;         str r1, [r0] ;store the ptr address in the ptr section of the pcb
00000338:             ; 
00000338: E2800048    ;         add r0, r0, #72 ;move to the ptr section of the next pcb
0000033C: E3A01000    ;         mov r1, #0 ;null pointer
00000340: E5001000    ;         str r1, [r0] ;store null pointer in the pcb address
00000344:             ; 
00000344:             ;         ; this is one of the first things the kernel does, so no active processes
00000344: E59F10C8    ;         ldr r1, =ACTIVE_PCB
00000348: E3A00000    ;         mov r0, #0
0000034C: E5010000    ;         str r0, [r1] ;make ACTIVE_PCB null
00000350:             ; 
00000350:             ;         ; this is one of the first things the kernel does, so no ready processes
00000350: E3A01E9F    ;         ldr r1, =READY_PCB
00000354: E5010000    ;         str r0, [r1] ;make READY_PCB null
00000358:             ; 
00000358:             ;         ; the tail of the READY_PCB is obviously also null
00000358: E59F10A0    ;         ldr r1, =READY_PCB_TAIL
0000035C: E5010000    ;         str r0, [r1] ;make READY_PCB_TAIL null
00000360:             ; 
00000360: E1A0F00E    ;         mov pc, lr
00000364:             ; 
00000364:             ; pcb_start
00000364:             ;         defs 76
000003B0:             ;         defs 76
000003FC:             ; 
000003FC: 000009E8    ; Remaining literals
00000400: 000009F4    ; 
00000404: 000009D8    ; 
00000408: 000009DC    ; 
0000040C: 000009E4    ; 
00000410: 000009D4    ; 
00000414: 000009EC    ; 

Symbol Table: Labels
: main                              00000020  Local -- ARM
: main_add                          0000004C  Local -- ARM
: addloop                           00000054  Local -- ARM
: main_sub                          00000060  Local -- ARM
: subloop                           00000068  Local -- ARM
: addNewProcess                     00000074  Local -- ARM
: moveToReadyQueue                  00000094  Local -- ARM
: movToRdyTail                      000000C4  Local -- ARM
: undefinedInstruction              000000E0  Local -- ARM
: supervisorCall                    000000E0  Local -- ARM
: prefetchAbort                     000000E0  Local -- ARM
: dataAbort                         000000E0  Local -- ARM
: irqRoutine                        000000E0  Local -- ARM
: fiqRoutine                        000000E0  Local -- ARM
: os_stack                          00000140  Local -- ARM
: add_stack                         000001A0  Local -- ARM
: sub_stack                         00000200  Local -- ARM
: TEMP_IRQ_LR                       000009D4  Value
: TEMP_R0                           000009D8  Value
: TEMP_R1                           000009DC  Value
: TEMP_IRQ_CPSR                     000009E0  Value
: TEMP_SYSTEM_CPSR                  000009E4  Value
: contextSwitch                     00000200  Local -- ARM
: storeToPCB                        0000025C  Local -- ARM
: temp_stack                        00000320  Local -- ARM
: FREE_PCB                          000009E8  Value
: ACTIVE_PCB                        000009EC  Value
: READY_PCB                         000009F0  Value
: READY_PCB_TAIL                    000009F4  Value
: initialise_PCB                    00000320  Local -- ARM
: pcb_start                         00000364  Local -- ARM
